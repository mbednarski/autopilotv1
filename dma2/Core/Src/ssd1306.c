/**
  ******************************************************************************
  * @file           : ssd1306.c
  * @brief          : SSD1306 OLED Display Driver Implementation (128x32)
  ******************************************************************************
  */

#include "ssd1306.h"
#include <string.h>

/* Private variables */
static I2C_HandleTypeDef *ssd1306_i2c;
static uint8_t SSD1306_Buffer[SSD1306_WIDTH * SSD1306_HEIGHT / 8];
static uint8_t currentX = 0;
static uint8_t currentY = 0;

/* 5x7 ASCII Font (characters 32-126) */
static const uint8_t Font5x7[][5] = {
    {0x00, 0x00, 0x00, 0x00, 0x00}, // space
    {0x00, 0x00, 0x5F, 0x00, 0x00}, // !
    {0x00, 0x07, 0x00, 0x07, 0x00}, // "
    {0x14, 0x7F, 0x14, 0x7F, 0x14}, // #
    {0x24, 0x2A, 0x7F, 0x2A, 0x12}, // $
    {0x23, 0x13, 0x08, 0x64, 0x62}, // %
    {0x36, 0x49, 0x55, 0x22, 0x50}, // &
    {0x00, 0x05, 0x03, 0x00, 0x00}, // '
    {0x00, 0x1C, 0x22, 0x41, 0x00}, // (
    {0x00, 0x41, 0x22, 0x1C, 0x00}, // )
    {0x14, 0x08, 0x3E, 0x08, 0x14}, // *
    {0x08, 0x08, 0x3E, 0x08, 0x08}, // +
    {0x00, 0x50, 0x30, 0x00, 0x00}, // ,
    {0x08, 0x08, 0x08, 0x08, 0x08}, // -
    {0x00, 0x60, 0x60, 0x00, 0x00}, // .
    {0x20, 0x10, 0x08, 0x04, 0x02}, // /
    {0x3E, 0x51, 0x49, 0x45, 0x3E}, // 0
    {0x00, 0x42, 0x7F, 0x40, 0x00}, // 1
    {0x42, 0x61, 0x51, 0x49, 0x46}, // 2
    {0x21, 0x41, 0x45, 0x4B, 0x31}, // 3
    {0x18, 0x14, 0x12, 0x7F, 0x10}, // 4
    {0x27, 0x45, 0x45, 0x45, 0x39}, // 5
    {0x3C, 0x4A, 0x49, 0x49, 0x30}, // 6
    {0x01, 0x71, 0x09, 0x05, 0x03}, // 7
    {0x36, 0x49, 0x49, 0x49, 0x36}, // 8
    {0x06, 0x49, 0x49, 0x29, 0x1E}, // 9
    {0x00, 0x36, 0x36, 0x00, 0x00}, // :
    {0x00, 0x56, 0x36, 0x00, 0x00}, // ;
    {0x08, 0x14, 0x22, 0x41, 0x00}, // <
    {0x14, 0x14, 0x14, 0x14, 0x14}, // =
    {0x00, 0x41, 0x22, 0x14, 0x08}, // >
    {0x02, 0x01, 0x51, 0x09, 0x06}, // ?
    {0x32, 0x49, 0x79, 0x41, 0x3E}, // @
    {0x7E, 0x11, 0x11, 0x11, 0x7E}, // A
    {0x7F, 0x49, 0x49, 0x49, 0x36}, // B
    {0x3E, 0x41, 0x41, 0x41, 0x22}, // C
    {0x7F, 0x41, 0x41, 0x22, 0x1C}, // D
    {0x7F, 0x49, 0x49, 0x49, 0x41}, // E
    {0x7F, 0x09, 0x09, 0x09, 0x01}, // F
    {0x3E, 0x41, 0x49, 0x49, 0x7A}, // G
    {0x7F, 0x08, 0x08, 0x08, 0x7F}, // H
    {0x00, 0x41, 0x7F, 0x41, 0x00}, // I
    {0x20, 0x40, 0x41, 0x3F, 0x01}, // J
    {0x7F, 0x08, 0x14, 0x22, 0x41}, // K
    {0x7F, 0x40, 0x40, 0x40, 0x40}, // L
    {0x7F, 0x02, 0x0C, 0x02, 0x7F}, // M
    {0x7F, 0x04, 0x08, 0x10, 0x7F}, // N
    {0x3E, 0x41, 0x41, 0x41, 0x3E}, // O
    {0x7F, 0x09, 0x09, 0x09, 0x06}, // P
    {0x3E, 0x41, 0x51, 0x21, 0x5E}, // Q
    {0x7F, 0x09, 0x19, 0x29, 0x46}, // R
    {0x46, 0x49, 0x49, 0x49, 0x31}, // S
    {0x01, 0x01, 0x7F, 0x01, 0x01}, // T
    {0x3F, 0x40, 0x40, 0x40, 0x3F}, // U
    {0x1F, 0x20, 0x40, 0x20, 0x1F}, // V
    {0x3F, 0x40, 0x38, 0x40, 0x3F}, // W
    {0x63, 0x14, 0x08, 0x14, 0x63}, // X
    {0x07, 0x08, 0x70, 0x08, 0x07}, // Y
    {0x61, 0x51, 0x49, 0x45, 0x43}, // Z
    {0x00, 0x7F, 0x41, 0x41, 0x00}, // [
    {0x02, 0x04, 0x08, 0x10, 0x20}, // backslash
    {0x00, 0x41, 0x41, 0x7F, 0x00}, // ]
    {0x04, 0x02, 0x01, 0x02, 0x04}, // ^
    {0x40, 0x40, 0x40, 0x40, 0x40}, // _
    {0x00, 0x01, 0x02, 0x04, 0x00}, // `
    {0x20, 0x54, 0x54, 0x54, 0x78}, // a
    {0x7F, 0x48, 0x44, 0x44, 0x38}, // b
    {0x38, 0x44, 0x44, 0x44, 0x20}, // c
    {0x38, 0x44, 0x44, 0x48, 0x7F}, // d
    {0x38, 0x54, 0x54, 0x54, 0x18}, // e
    {0x08, 0x7E, 0x09, 0x01, 0x02}, // f
    {0x0C, 0x52, 0x52, 0x52, 0x3E}, // g
    {0x7F, 0x08, 0x04, 0x04, 0x78}, // h
    {0x00, 0x44, 0x7D, 0x40, 0x00}, // i
    {0x20, 0x40, 0x44, 0x3D, 0x00}, // j
    {0x7F, 0x10, 0x28, 0x44, 0x00}, // k
    {0x00, 0x41, 0x7F, 0x40, 0x00}, // l
    {0x7C, 0x04, 0x18, 0x04, 0x78}, // m
    {0x7C, 0x08, 0x04, 0x04, 0x78}, // n
    {0x38, 0x44, 0x44, 0x44, 0x38}, // o
    {0x7C, 0x14, 0x14, 0x14, 0x08}, // p
    {0x08, 0x14, 0x14, 0x18, 0x7C}, // q
    {0x7C, 0x08, 0x04, 0x04, 0x08}, // r
    {0x48, 0x54, 0x54, 0x54, 0x20}, // s
    {0x04, 0x3F, 0x44, 0x40, 0x20}, // t
    {0x3C, 0x40, 0x40, 0x20, 0x7C}, // u
    {0x1C, 0x20, 0x40, 0x20, 0x1C}, // v
    {0x3C, 0x40, 0x30, 0x40, 0x3C}, // w
    {0x44, 0x28, 0x10, 0x28, 0x44}, // x
    {0x0C, 0x50, 0x50, 0x50, 0x3C}, // y
    {0x44, 0x64, 0x54, 0x4C, 0x44}, // z
    {0x00, 0x08, 0x36, 0x41, 0x00}, // {
    {0x00, 0x00, 0x7F, 0x00, 0x00}, // |
    {0x00, 0x41, 0x36, 0x08, 0x00}, // }
    {0x08, 0x04, 0x08, 0x10, 0x08}, // ~
};

/* Private function prototypes */
static HAL_StatusTypeDef SSD1306_WriteCommand(uint8_t cmd);
static HAL_StatusTypeDef SSD1306_WriteData(uint8_t* data, size_t size);

/**
  * @brief  Write command to SSD1306
  * @param  cmd: Command byte
  * @retval HAL status
  */
static HAL_StatusTypeDef SSD1306_WriteCommand(uint8_t cmd)
{
    uint8_t buffer[2] = {0x00, cmd};  // 0x00 = command mode
    return HAL_I2C_Master_Transmit(ssd1306_i2c, SSD1306_I2C_ADDR, buffer, 2, 100);
}

/**
  * @brief  Write data to SSD1306
  * @param  data: Data buffer
  * @param  size: Size of data
  * @retval HAL status
  */
static HAL_StatusTypeDef SSD1306_WriteData(uint8_t* data, size_t size)
{
    uint8_t buffer[size + 1];
    buffer[0] = 0x40;  // 0x40 = data mode
    memcpy(&buffer[1], data, size);
    return HAL_I2C_Master_Transmit(ssd1306_i2c, SSD1306_I2C_ADDR, buffer, size + 1, 100);
}

/**
  * @brief  Initialize SSD1306 OLED display (128x32)
  * @param  hi2c: I2C handle
  * @retval HAL status
  */
HAL_StatusTypeDef SSD1306_Init(I2C_HandleTypeDef *hi2c)
{
    ssd1306_i2c = hi2c;
    HAL_Delay(100);  // Wait for display to power up

    // Init sequence for 128x32 SSD1306
    SSD1306_WriteCommand(SSD1306_CMD_DISPLAY_OFF);
    SSD1306_WriteCommand(SSD1306_CMD_SET_MUX_RATIO);
    SSD1306_WriteCommand(0x1F);  // 32-1
    SSD1306_WriteCommand(SSD1306_CMD_SET_DISPLAY_OFFSET);
    SSD1306_WriteCommand(0x00);
    SSD1306_WriteCommand(SSD1306_CMD_SET_START_LINE | 0x00);
    SSD1306_WriteCommand(SSD1306_CMD_SEG_REMAP_INV);
    SSD1306_WriteCommand(SSD1306_CMD_COM_SCAN_DEC);
    SSD1306_WriteCommand(SSD1306_CMD_SET_COM_PINS);
    SSD1306_WriteCommand(0x02);  // Sequential COM pin config for 32px
    SSD1306_WriteCommand(SSD1306_CMD_SET_CONTRAST);
    SSD1306_WriteCommand(0x8F);
    SSD1306_WriteCommand(SSD1306_CMD_CHARGE_PUMP);
    SSD1306_WriteCommand(0x14);  // Enable charge pump
    SSD1306_WriteCommand(SSD1306_CMD_MEMORY_MODE);
    SSD1306_WriteCommand(0x00);  // Horizontal addressing mode
    SSD1306_WriteCommand(SSD1306_CMD_NORMAL_DISPLAY);
    SSD1306_WriteCommand(SSD1306_CMD_DEACTIVATE_SCROLL);
    SSD1306_WriteCommand(SSD1306_CMD_DISPLAY_ON);

    // Clear display
    SSD1306_Fill(0);
    SSD1306_UpdateScreen();

    return HAL_OK;
}

/**
  * @brief  Fill entire buffer with specified color
  * @param  color: 0x00 for black, 0xFF for white
  * @retval None
  */
void SSD1306_Fill(uint8_t color)
{
    memset(SSD1306_Buffer, color, sizeof(SSD1306_Buffer));
}

/**
  * @brief  Update OLED screen with buffer content
  * @retval None
  */
void SSD1306_UpdateScreen(void)
{
    // Set column address range (0-127)
    SSD1306_WriteCommand(SSD1306_CMD_COLUMN_ADDR);
    SSD1306_WriteCommand(0);
    SSD1306_WriteCommand(127);

    // Set page address range (0-3 for 32px height)
    SSD1306_WriteCommand(SSD1306_CMD_PAGE_ADDR);
    SSD1306_WriteCommand(0);
    SSD1306_WriteCommand(3);

    // Write entire buffer
    SSD1306_WriteData(SSD1306_Buffer, sizeof(SSD1306_Buffer));
}

/**
  * @brief  Set cursor position in pixels
  * @param  x: X position (0-127)
  * @param  y: Y position (0-31)
  * @retval None
  */
void SSD1306_GotoXY(uint8_t x, uint8_t y)
{
    currentX = x;
    currentY = y;
}

/**
  * @brief  Set cursor position by character line
  * @param  x: X position in pixels (0-127)
  * @param  line: Line number (0-3 for 32px height)
  * @retval None
  */
void SSD1306_SetCursor(uint8_t x, uint8_t line)
{
    currentX = x;
    currentY = line * 8;  // Each line is 8 pixels high
}

/**
  * @brief  Write single character to display buffer
  * @param  ch: ASCII character to write
  * @retval None
  */
void SSD1306_Putc(char ch)
{
    if (ch < 32 || ch > 126) {
        return;  // Character not in font table
    }

    if (currentX + 6 > SSD1306_WIDTH) {
        return;  // No space left on line
    }

    // Get font data for character
    const uint8_t *font_char = Font5x7[ch - 32];

    // Write font data to buffer
    for (uint8_t i = 0; i < 5; i++) {
        uint8_t x = currentX + i;
        uint8_t page = currentY / 8;

        if (x < SSD1306_WIDTH && page < 4) {
            SSD1306_Buffer[x + (page * SSD1306_WIDTH)] = font_char[i];
        }
    }

    // Add 1 pixel space after character
    if (currentX + 5 < SSD1306_WIDTH) {
        uint8_t page = currentY / 8;
        SSD1306_Buffer[currentX + 5 + (page * SSD1306_WIDTH)] = 0x00;
    }

    currentX += 6;  // Move cursor (5 pixels + 1 space)
}

/**
  * @brief  Write string to display buffer
  * @param  str: Null-terminated string
  * @retval None
  */
void SSD1306_Puts(char* str)
{
    while (*str) {
        SSD1306_Putc(*str++);
    }
}

/**
  * @brief  Clear display buffer and reset cursor
  * @retval None
  */
void SSD1306_Clear(void)
{
    SSD1306_Fill(0);
    currentX = 0;
    currentY = 0;
}
